# RPC
## 名词解析
RPC是指Remote Procedure Call Protocol

### Restful：

严格意义上说接口很规范，操作对象即为资源，对资源的四种操作（post、get、put、delete），并且参数都放在URL上,但是不严格的说Http+json、Http+xml，常见的http api都可以称为Rest接口。

### Rpc:
我们常说的远程方法调用，就是像调用本地方法一样调用远程方法，通信协议大多采用二进制方式

### 使用感受

比如服务A想要调用服务B上的某个方法/函数，使用方可以忽略底层的传输层的细节，专注于方法的使用。就像调用一个本地函数，使用十分便捷，不需要关心接口的url，校验规则，返回值解析等过程。

#### 异常
本地和远程调用差异：
1. 本地调用一定会执行，而远程调用则不一定，调用消息可能因为网络原因并未发送到服务方。
2. 本地调用只会抛出接口声明的异常，而远程调用还会跑出 RPC 框架运行时的其他异常。
3. 本地调用和远程调用的性能可能差距很大，这取决于 RPC 固有消耗所占的比重。
本地调用的固有消耗是纳秒级，而 RPC 的固有消耗是在毫秒级。那么对于过于轻量的计算任务就并不合适导出远程接口由独立的进程提供服务，只有花在计算任务上时间远远高于 RPC 的固有消耗才值得导出为远程接口提供服务。



### thrift:

facebook提出的开源的跨平台的RPC框架。 

https://github.com/apache/thrift

## RPC

### RPC的好处：
RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的区分本地调用和远程调用。
服务化的一个好处就是，不限定服务的提供方使用什么技术选型，能够实现大公司跨团队的技术解耦。 

如果没有统一的服务框架，RPC框架，各个团队的服务提供方就需要各自实现一套序列化、反序列化、网络框架、连接池、收发线程、超时处理、状态机等“业务之外”的重复技术劳动，造成整体的低效。所以，统一RPC框架把上述“业务之外”的技术劳动统一处理，是服务化首要解决的问题

### RPC不足:

在微服务架构中，各个服务之间可能千差万别，rest接口更加灵活，如果使用RPC则会有很多约束
 
## http vs 高性能二进制协议

http相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，相应的，如果采用http，无疑在你实现SDK之前，支持了所有语言，所以，现在开源中间件，基本最先支持的几个协议都包含RESTful。

RPC协议性能要高的多，例如Protobuf、Thrift、Kyro等，（如果算上序列化）吞吐量大概能达到http的二倍。响应时间也更为出色。千万不要小看这点性能损耗，公认的，微服务做的比较好的，例如，netflix、阿里，曾经都传出过为了提升性能而合并服务。如果是交付型的项目，性能更为重要，因为你卖给客户往往靠的就是性能上微弱的优势。RESTful

你可以看看，无论是Google、Amazon、netflix（据说很可能转向grpc），还是阿里，实际上内部都是采用性能更高的RPC方式。而对外开放的才是RESTful。
### 使用场景：

restful:  对外提供的服务，更加规范、通用、易扩展、已维护，具有较高的安全性(https)。

rpc:  对内提供的服务，尤其适用于需要进行大量数据交互的服务(thrift提供高效的压缩协议，交互更加简洁，吞吐量更大)、 高频率交互的服务(可以考虑建立TCP长连接，比如即将开工的大权限系统)

### 性能对比:
http://blog.csdn.net/code52/article/details/21015361

http://www.eit.name/blog/read.php?566

## Thift
### 模块解析
http://www.3023.com/5/45169461.html

thrift整体的逻辑分成两大部分：

* 静态代码生成。使用者按照规范编写接口描述语言IDL（实际就是你的接口函数 实体类），然后使用thrift提供的编译器，将这个IDL编译成你想要的语言的代码。然后留出需要实现的地方，你去填写具体的实现逻辑。现在他支持的语言有很多，比如c/c 、java、python、ruby、c#、go、perl等等，甚至还支持javascript；

* runtime运行时。将上述生成的代码 他提供的库，将我们的逻辑设置成为回调，启动库里的server，就可以提供RPC服务。而客户端也是同样的方式，便能启动相关的调用。


#### 静态部分的代码生成

所谓的IDL文件实际就可以看成一个特殊语言的代码（类似于c 或者java），提供服务接口和实体结构两种类型。服务接口的作用类似于函数，而实体结构类似于结构体或者是java-bean这样的东东。

然后thrift提供的gen工具，可以生成多种支持的语言代码。代码分成server和client两部分。开发者需要填充server端的实现逻辑，而客户端代码则可以直接调用。

transport层就是我们之前说的传输协议（比如：tcp、http等）；

protocol层则是数据组织协议（比如：json、xml等）；

server层是我们的服务器模型，怎么样组织我们的服务器模型来保证我们能提供尽量高并发、高可用的服务能力（比如：epoll、select等）。

具体的模块解析可以看下原文
http://www.3023.com/5/45169461.html

